<!doctype html>
<html lang="et">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jutumasin</title>
  <style>
    :root{
      --bg1:#07000a; --bg2:#120014;
      --pink:#ff4da6; --pink2:#ff1f8f;
      --text:#ffe9f5; --muted:#d9a9c6;
      --card:#12000f; --card2:#1b0018;
      --shadow: 0 26px 80px rgba(0,0,0,.75);
      --r:22px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; height:100vh;
      display:flex; align-items:center; justify-content:center;
      padding:0;
      font-family: "Segoe UI Variable Display","Segoe UI Variable","Segoe UI",system-ui,-apple-system,Roboto,Arial,sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 15% 10%, rgba(255,77,166,.22), transparent 58%),
        radial-gradient(1100px 700px at 85% 20%, rgba(255,31,143,.18), transparent 62%),
        linear-gradient(180deg, var(--bg2), var(--bg1));
      overflow:hidden;
    }

    .bgHearts{
      position:fixed; inset:-35%;
      pointer-events:none;
      opacity:.13;
      filter: blur(.35px);
      animation: floatUp 170s linear infinite;
      background-image:
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='640' height='640' viewBox='0 0 640 640'%3E%3Cg fill='%23ff4da6' fill-opacity='0.25'%3E%3Ctext x='60' y='360' font-size='220'%3E%E2%99%A5%3C/text%3E%3Ctext x='360' y='260' font-size='160'%3E%E2%99%A5%3C/text%3E%3Ctext x='260' y='580' font-size='190'%3E%E2%99%A5%3C/text%3E%3C/g%3E%3C/svg%3E");
      background-size: 640px 640px;
      background-repeat: repeat;
    }
    .bgHearts.bg2{
      opacity:.09;
      filter: blur(.5px);
      animation-duration: 240s;
      transform: translateY(12%) scale(1.25);
      background-image:
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='860' height='860' viewBox='0 0 860 860'%3E%3Cg fill='%23ff1f8f' fill-opacity='0.18'%3E%3Ctext x='90' y='500' font-size='320'%3E%E2%99%A5%3C/text%3E%3Ctext x='520' y='380' font-size='220'%3E%E2%99%A5%3C/text%3E%3Ctext x='390' y='820' font-size='260'%3E%E2%99%A5%3C/text%3E%3C/g%3E%3C/svg%3E");
      background-size: 860px 860px;
      background-repeat: repeat;
    }
    @keyframes floatUp{
      from{ transform: translateY(18%); }
      to{ transform: translateY(-18%); }
    }

    .app{
      width:min(520px, 100%);
      height:100%;
      max-height:100vh;
      display:flex; flex-direction:column;
      background: linear-gradient(180deg, rgba(255,77,166,.12), rgba(0,0,0,.25));
      position:relative;
    }
    header{
      padding:14px 16px;
      display:flex; align-items:center; justify-content:center;
      border-bottom:1px solid rgba(255,77,166,.22);
      background: linear-gradient(90deg, rgba(255,77,166,.18), rgba(0,0,0,.18));
    }
    .brand{
      display:flex; align-items:center; gap:10px;
      font-weight:900; letter-spacing:.2px; font-size:18px;
    }

    main{flex:1; display:flex; flex-direction:column; min-height:0}
    .screen{flex:1; display:none; padding:16px; min-height:0}
    .screen.active{display:flex; flex-direction:column; gap:14px}

    .row{display:flex; align-items:center; justify-content:space-between; gap:10px}
    .stat{
      padding:10px 12px; border-radius:16px;
      border:1px solid rgba(255,77,166,.22);
      background: rgba(0,0,0,.22);
      font-size:12px; color:var(--muted);
      white-space:nowrap;
    }
    .hint{font-size:12px; color:var(--muted); line-height:1.35}

    .grid{display:grid; gap:12px; grid-template-columns:1fr 1fr}
    .choice{
      padding:16px; border-radius:var(--r);
      background: linear-gradient(180deg, rgba(255,77,166,.10), rgba(0,0,0,.26));
      border:1px solid rgba(255,77,166,.22);
      cursor:pointer;
      min-height:92px;
      display:flex; flex-direction:column; justify-content:center;
    }
    .choice h3{margin:0 0 6px 0; font-size:15px; font-weight:900}
    .choice p{margin:0; color:var(--muted); font-size:12px}

    .cardArea{
      flex:1;
      display:flex; align-items:center; justify-content:center;
      position:relative;
      padding:0;
      min-height:0;
    }
    .deck{
      width:100%;
      height:100%;
      display:flex; align-items:center; justify-content:center;
      position:relative;
      min-height:0;
    }
    .swipeCard{
      width:100%;
      max-width:520px;
      height:100%;
      border-radius:var(--r);
      background: linear-gradient(180deg, var(--card2), var(--card));
      border:1px solid rgba(255,77,166,.30);
      box-shadow: 0 18px 70px rgba(0,0,0,.65);
      position:absolute;
      touch-action:none;
      user-select:none;
      overflow:hidden;
      transform: translate(0,0) rotate(0deg);
      transition: transform 160ms ease, opacity 160ms ease;
    }
    .inner{
      height:100%;
      padding:26px 24px;
      display:flex; flex-direction:column; gap:20px;
      background:
        radial-gradient(1100px 700px at 20% 0%, rgba(255,77,166,.22), transparent 62%),
        radial-gradient(1100px 700px at 85% 20%, rgba(255,31,143,.18), transparent 62%);
    }
    .title{font-size:52px; font-weight:950; line-height:1.0}
    .desc{font-size:26px; color:rgba(255,233,245,.95); line-height:1.25}
    .foot{
      margin-top:auto;
      font-size:14px;
      color:var(--muted);
      border-top:1px solid rgba(255,77,166,.22);
      padding-top:14px;
    }

    .stamp{
      position:absolute; top:16px; right:16px;
      font-weight:950; letter-spacing:.12em; font-size:16px;
      padding:10px 14px; border-radius:14px;
      border:2px solid rgba(255,255,255,.20);
      transform: rotate(8deg);
      opacity:0;
      pointer-events:none;
    }
    .stamp.edasi{color:var(--pink); border-color: rgba(255,77,166,.55); background: rgba(255,77,166,.12)}
    .stamp.tagasi{color:#ff6b8b; border-color: rgba(255,107,139,.55); background: rgba(255,107,139,.10)}
    .stamp.parim{color:#ffd1ea; border-color: rgba(255,209,234,.55); background: rgba(255,209,234,.12); transform: rotate(-6deg); left:16px; right:auto}

    .star{
      position:absolute; right:14px; bottom:14px;
      width:46px; height:46px; border-radius:999px;
      display:flex; align-items:center; justify-content:center;
      border:1px solid rgba(255,209,234,.40);
      background: rgba(0,0,0,.25);
      box-shadow: 0 12px 30px rgba(0,0,0,.45);
      font-size:20px;
      pointer-events:none;
    }

    .controls{
      padding:14px 16px;
      display:none;
      gap:12px; justify-content:center;
      border-top:1px solid rgba(255,77,166,.22);
      background: rgba(0,0,0,.22);
    }
    button{
      appearance:none; border:none; cursor:pointer;
      border-radius:999px; padding:12px 16px;
      color:var(--text); font-weight:900;
      background: linear-gradient(180deg, rgba(255,77,166,.18), rgba(0,0,0,.25));
      border:1px solid rgba(255,77,166,.26);
      min-width:110px;
    }
    button:active{transform: translateY(1px)}
    button[disabled]{opacity:.45; cursor:default}
  </style>
</head>
<body>
  <div class="bgHearts"></div>
  <div class="bgHearts bg2"></div>

  <div class="app">
    <header>
      <div class="brand"><span>Jutumasin</span></div>
    </header>

    <main>
      <section id="menuScreen" class="screen active">
        <div class="row">
          <div class="stat">Vali</div>
          <div class="stat" id="menuCounts">Ajalugu: 0 • Parimad: 0</div>
        </div>
        <div class="grid" id="menuGrid"></div>
        <div class="hint">
          Mäng: vasak = <b>tagasi</b>, parem = <b>edasi</b>, üles = <b>parim</b> (⭐).<br/>
          Ajalugu/Parimad: vasak = tagasi, parem = edasi.
        </div>
      </section>

      <section id="gameScreen" class="screen">
        <div class="row">
          <div class="stat" id="deckName">Tüüp: —</div>
          <div class="stat" id="progress">0</div>
        </div>
        <div class="cardArea"><div class="deck" id="deck"></div></div>
      </section>

      <section id="historyScreen" class="screen">
        <div class="row">
          <div class="stat" id="historyName">Ajalugu: —</div>
          <div class="stat" id="historyPos">0</div>
        </div>
        <div class="cardArea"><div class="deck" id="historyDeck"></div></div>
      </section>

      <section id="bestScreen" class="screen">
        <div class="row">
          <div class="stat" id="bestName">Parimad: —</div>
          <div class="stat" id="bestPos">0</div>
        </div>
        <div class="cardArea"><div class="deck" id="bestDeck"></div></div>
      </section>
    </main>

    <div class="controls" id="controls">
      <button id="btnBack">⬅️ Tagasi</button>
      <button id="btnMenu">☰ Menüü</button>
      <button id="btnNext">Edasi ➡️</button>
      <button id="btnBest">⭐ Parim</button>
    </div>
  </div>

  <script>
    const DECKS = {
      "Dating": [
        { title:"Kohv ja jalutuskäik", desc:"Kiire vibe-check. Lihtne, aus, turvaline.", foot:"• Dating" },
        { title:"Muuseum", desc:"Räägi kunstist (või vähemalt raamidest).", foot:"• Dating" },
        { title:"Õhtune linnatiir", desc:"Tulede all on kõik natuke romantilisem.", foot:"• Dating" },
        { title:"Kokkame koos", desc:"Kui läheb pekki, tellime pitsat.", foot:"• Dating" }
      ],
      "Spicy": [
        { title:"Salajane koht", desc:"Üks vihje. Üks sihtkoht. Üks risk.", foot:"• Spicy" },
        { title:"Julge mäng", desc:"Küsimused, mis lähevad natuke liiga ausaks.", foot:"• Spicy" },
        { title:"Öine sõit", desc:"Muusika põhja ja mõtted välja.", foot:"• Spicy" },
        { title:"Üks asi", desc:"Ütle üks asi, mida sa päriselt tahad.", foot:"• Spicy" }
      ],
      "Couples": [
        { title:"Pühapäeva rituaal", desc:"Loome oma väikese traditsiooni.", foot:"• Couples" },
        { title:"Unistuste reis", desc:"Valime sihi ja hakkame koguma.", foot:"• Couples" },
        { title:"Digipaus", desc:"Telefonid kõrvale. Meie aeg.", foot:"• Couples" },
        { title:"Tänulikkuse ring", desc:"Ütle 3 asja, mida sa hindad.", foot:"• Couples" }
      ],
      "Fun": [
        { title:"Kiirchallenge", desc:"10 minutit ja 3 naljakat ülesannet.", foot:"• Fun" },
        { title:"Karaoke duel", desc:"Halb laul on ka laul.", foot:"• Fun" },
        { title:"Mini-piknik", desc:"Poes 5€ limiit. Loovus võidab.", foot:"• Fun" },
        { title:"Mälumäng", desc:"Kes kaotab, teeb järgmise kohvi.", foot:"• Fun" }
      ]
    };

    const State = {
      deckKey: null,
      cards: [],
      index: 0,
      histories: {},
      bests: {},
      viewDeckKey: null,
      viewMode: "menu",
      viewPos: 0
    };

    const el = {
      menu: document.getElementById("menuScreen"),
      game: document.getElementById("gameScreen"),
      history: document.getElementById("historyScreen"),
      best: document.getElementById("bestScreen"),
      menuGrid: document.getElementById("menuGrid"),
      menuCounts: document.getElementById("menuCounts"),
      deck: document.getElementById("deck"),
      historyDeck: document.getElementById("historyDeck"),
      bestDeck: document.getElementById("bestDeck"),
      deckName: document.getElementById("deckName"),
      progress: document.getElementById("progress"),
      historyName: document.getElementById("historyName"),
      historyPos: document.getElementById("historyPos"),
      bestName: document.getElementById("bestName"),
      bestPos: document.getElementById("bestPos"),
      controls: document.getElementById("controls"),
      btnBack: document.getElementById("btnBack"),
      btnMenu: document.getElementById("btnMenu"),
      btnNext: document.getElementById("btnNext"),
      btnBest: document.getElementById("btnBest")
    };

    /* Näitab õige vaate ja peidab nupuriba menüüs (menüüs peab olema puhas). */
    function showScreen(name){
      el.menu.classList.toggle("active", name === "menu");
      el.game.classList.toggle("active", name === "game");
      el.history.classList.toggle("active", name === "history");
      el.best.classList.toggle("active", name === "best");
      State.viewMode = name;
      el.controls.style.display = (name === "menu") ? "none" : "flex";
      updateButtons();
    }

    /* Loendab map'i (ajalugu/parimad) kogusummad menüü statistikaks. */
    function totalCount(map){
      let n=0; Object.keys(map).forEach(k => n += (map[k]?.length || 0)); return n;
    }

    /* Ehitas menüü 6 valikuga: 4 pakki + Ajalugu + Parimad. */
    function buildMenu(){
      const hTotal = totalCount(State.histories);
      const bTotal = totalCount(State.bests);
      el.menuCounts.textContent = `Ajalugu: ${hTotal} • Parimad: ${bTotal}`;

      const items = [
        { title:"Dating",  sub:"Alusta", action:()=>startGame("Dating") },
        { title:"Spicy",   sub:"Alusta", action:()=>startGame("Spicy") },
        { title:"Couples", sub:"Alusta", action:()=>startGame("Couples") },
        { title:"Fun",     sub:"Alusta", action:()=>startGame("Fun") },
        { title:"Ajalugu", sub:`Kirjeid: ${hTotal}`, action:()=>openList("history") },
        { title:"Parimad", sub:`Kirjeid: ${bTotal}`, action:()=>openList("best") }
      ];

      el.menuGrid.innerHTML = "";
      items.forEach(it=>{
        const c=document.createElement("div");
        c.className="choice";
        c.innerHTML = `<h3>${it.title}</h3><p>${it.sub}</p>`;
        c.addEventListener("click", it.action);
        el.menuGrid.appendChild(c);
      });
    }

    /* Seab nuppude oleku vastavalt vaatele ja positsioonile (history/best). */
    function updateButtons(){
      const isGame = State.viewMode === "game";
      el.btnBest.style.display = isGame ? "inline-block" : "none";

      if(State.viewMode === "history"){
        const list = State.histories[State.viewDeckKey] || [];
        el.btnBack.disabled = !(list.length && State.viewPos > 0);
        el.btnNext.disabled = !(list.length && State.viewPos < list.length - 1);
      } else if(State.viewMode === "best"){
        const list = State.bests[State.viewDeckKey] || [];
        el.btnBack.disabled = !(list.length && State.viewPos > 0);
        el.btnNext.disabled = !(list.length && State.viewPos < list.length - 1);
      } else {
        el.btnBack.disabled = false;
        el.btnNext.disabled = false;
      }
    }

    /* Käivitab mängu valitud pakiga ja valmistab ajalugu/parimad konteinerid ette. */
    function startGame(deckKey){
      State.deckKey = deckKey;
      State.cards = shuffle([...DECKS[deckKey]]);
      State.index = 0;
      if(!State.histories[deckKey]) State.histories[deckKey] = [];
      if(!State.bests[deckKey]) State.bests[deckKey] = [];
      el.deckName.textContent = `Tüüp: ${deckKey}`;
      showScreen("game");
      renderStack();
      updateProgress();
      buildMenu();
    }

    /* Avab Ajalugu või Parimad (vaikimisi viimati mängitud pakk, muidu esimene). */
    function openList(mode){
      const dk = State.deckKey || Object.keys(DECKS)[0];
      State.viewDeckKey = dk;
      State.viewPos = 0;

      if(mode==="history"){
        el.historyName.textContent = `Ajalugu: ${dk}`;
        showScreen("history");
        renderViewCard();
        updateViewPos();
      } else {
        el.bestName.textContent = `Parimad: ${dk}`;
        showScreen("best");
        renderViewCard();
        updateViewPos();
      }
    }

    /* Näitab ainult “mitmes kaart on” (ilma koguarvuta). */
    function updateProgress(){
      el.progress.textContent = String(State.index + 1);
    }

    /* Renderdab kaks kaarti (järgmine + aktiivne) ja lõpetab pakis otsa saamisel menüüsse. */
    function renderStack(){
      el.deck.innerHTML = "";
      const next = State.cards[State.index + 1];
      const top  = State.cards[State.index];
      if(next) el.deck.appendChild(makeCard(next, true, "game", true));
      if(top)  el.deck.appendChild(makeCard(top, false, "game", true));
      if(!top){ showScreen("menu"); buildMenu(); }
    }

    /* Loob ühe kaardielemendi ja lisab swipe handlerid ainult pealmisele kaardile. */
    function makeCard(card, isBehind, mode, showStar){
      const wrap = document.createElement("div");
      wrap.className = "swipeCard";
      wrap.style.transform = isBehind ? "scale(0.96) translateY(10px)" : "translate(0,0)";
      wrap.style.opacity = isBehind ? "0.93" : "1";

      const stampNext = document.createElement("div");
      stampNext.className = "stamp edasi";
      stampNext.textContent = "EDASI";

      const stampBack = document.createElement("div");
      stampBack.className = "stamp tagasi";
      stampBack.textContent = "TAGASI";

      const stampBest = document.createElement("div");
      stampBest.className = "stamp parim";
      stampBest.textContent = "PARIM";

      const inner = document.createElement("div");
      inner.className = "inner";
      inner.innerHTML = `
        <div class="title">${card.title}</div>
        <div class="desc">${card.desc}</div>
        <div class="foot">${card.foot || ""}</div>
      `;

      wrap.appendChild(stampNext);
      wrap.appendChild(stampBack);
      wrap.appendChild(stampBest);

      if(showStar){
        const star = document.createElement("div");
        star.className = "star";
        star.textContent = "⭐";
        wrap.appendChild(star);
      }

      wrap.appendChild(inner);

      if(!isBehind){
        if(mode==="game") attachSwipeGame(wrap, stampNext, stampBack, stampBest);
        if(mode==="view") attachSwipeView(wrap);
      }
      return wrap;
    }

    /* Mängu swipe: vasak=TAGASI, parem=EDASI, üles=PARIM; hoiab thresholdid stabiilsed mobiilis. */
    function attachSwipeGame(cardEl, nextStamp, backStamp, bestStamp){
      let sx=0, sy=0, dx=0, dy=0, dragging=false;

      cardEl.addEventListener("pointerdown", (e)=>{
        dragging=true;
        cardEl.setPointerCapture(e.pointerId);
        sx=e.clientX; sy=e.clientY;
        cardEl.style.transition="none";
      });

      cardEl.addEventListener("pointermove", (e)=>{
        if(!dragging) return;
        dx=e.clientX-sx; dy=e.clientY-sy;

        const rot = clamp(dx/14, -18, 18);
        cardEl.style.transform = `translate(${dx}px, ${dy}px) rotate(${rot}deg)`;

        const aNext = clamp((dx-40)/120, 0, 1);
        const aBack = clamp((-dx-40)/120, 0, 1);
        const aBest = clamp((-dy-50)/140, 0, 1);

        nextStamp.style.opacity = aNext.toFixed(2);
        backStamp.style.opacity = aBack.toFixed(2);
        bestStamp.style.opacity = aBest.toFixed(2);
      });

      cardEl.addEventListener("pointerup", ()=>{
        if(!dragging) return;
        dragging=false;
        cardEl.style.transition="transform 180ms ease, opacity 180ms ease";

        const tX=120, tY=130;
        if(dy < -tY && Math.abs(dx) < 140) commitSwipeGame(cardEl, "PARIM");
        else if(dx > tX) commitSwipeGame(cardEl, "EDASI");
        else if(dx < -tX) commitSwipeGame(cardEl, "TAGASI");
        else{
          cardEl.style.transform="translate(0,0) rotate(0deg)";
          nextStamp.style.opacity=0; backStamp.style.opacity=0; bestStamp.style.opacity=0;
        }
      });
    }

    /* Rakendab swipe tulemuse: animatsioon + ajaloo/parimate salvestus + indeksi edasi liigutus. */
    function commitSwipeGame(cardEl, otsus){
      let tx=0, ty=0, rot=0;
      if(otsus==="EDASI"){ tx=520; ty=-40; rot=18; }
      if(otsus==="TAGASI"){ tx=-520; ty=-40; rot=-18; }
      if(otsus==="PARIM"){ tx=0; ty=-620; rot=0; }

      cardEl.style.transform = `translate(${tx}px, ${ty}px) rotate(${rot}deg)`;
      cardEl.style.opacity = "0";

      const dk = State.deckKey;
      const card = State.cards[State.index];

      State.histories[dk].push({ card, otsus });

      if(otsus==="PARIM"){
        const key = card.title + "||" + card.desc;
        const exists = State.bests[dk].some(x => (x.card.title + "||" + x.card.desc) === key);
        if(!exists) State.bests[dk].push({ card });
      }

      setTimeout(()=>{
        State.index++;
        updateProgress();
        renderStack();
        buildMenu();
      }, 170);
    }

    /* Vaate (Ajalugu/Parimad) swipe: vasak tagasi, parem edasi; ei muuda andmeid. */
    function attachSwipeView(cardEl){
      let sx=0, dx=0, dragging=false;

      cardEl.addEventListener("pointerdown",(e)=>{
        dragging=true;
        cardEl.setPointerCapture(e.pointerId);
        sx=e.clientX;
        cardEl.style.transition="none";
      });

      cardEl.addEventListener("pointermove",(e)=>{
        if(!dragging) return;
        dx=e.clientX-sx;
        const rot = clamp(dx/18, -12, 12);
        cardEl.style.transform = `translate(${dx}px, 0px) rotate(${rot}deg)`;
      });

      cardEl.addEventListener("pointerup",()=>{
        if(!dragging) return;
        dragging=false;
        cardEl.style.transition="transform 180ms ease, opacity 180ms ease";
        const t=110;
        if(dx<-t) viewStep(-1);
        else if(dx>t) viewStep(+1);
        else cardEl.style.transform="translate(0,0) rotate(0deg)";
      });
    }

    /* Renderdab ühe kaardi Ajalugu/Parimad vaates (tühja korral ilma tähekese ja stampideta). */
    function renderViewCard(){
      const dk = State.viewDeckKey;
      const mode = State.viewMode;

      let list, host, isHistory;
      if(mode==="history"){ list = State.histories[dk] || []; host = el.historyDeck; isHistory = true; }
      else { list = State.bests[dk] || []; host = el.bestDeck; isHistory = false; }

      host.innerHTML = "";

      const item = list[State.viewPos];
      if(!item){
        const empty = makeCard({title:"Pole midagi", desc:"Alusta mängu ja tee swiped.", foot:"• " + dk}, false, "view", false);
        empty.querySelectorAll(".stamp").forEach(s => s.style.opacity = 0);
        host.appendChild(empty);
        updateButtons();
        return;
      }

      const c = makeCard(item.card, false, "view", false);
      c.querySelectorAll(".stamp").forEach(s => s.style.opacity = 0);

      if(isHistory){
        const sNext = c.querySelector(".stamp.edasi");
        const sBack = c.querySelector(".stamp.tagasi");
        const sBest = c.querySelector(".stamp.parim");
        sNext.style.opacity = item.otsus==="EDASI" ? 1 : 0;
        sBack.style.opacity = item.otsus==="TAGASI" ? 1 : 0;
        sBest.style.opacity = item.otsus==="PARIM" ? 1 : 0;
      } else {
        const sBest = c.querySelector(".stamp.parim");
        sBest.style.opacity = 1;
      }

      host.appendChild(c);
      updateButtons();
    }

    /* Uuendab Ajalugu/Parimad positsiooni näidu (ainult index). */
    function updateViewPos(){
      const dk = State.viewDeckKey;
      const mode = State.viewMode;
      const list = (mode==="history") ? (State.histories[dk] || []) : (State.bests[dk] || []);
      const pos = list.length ? (State.viewPos + 1) : 0;
      if(mode==="history") el.historyPos.textContent = String(pos);
      else el.bestPos.textContent = String(pos);
      updateButtons();
    }

    /* Liigutab Ajalugu/Parimad vaates positsiooni ja renderdab uuesti. */
    function viewStep(dir){
      const dk = State.viewDeckKey;
      const mode = State.viewMode;
      const list = (mode==="history") ? (State.histories[dk] || []) : (State.bests[dk] || []);
      if(!list.length) return;
      State.viewPos = clamp(State.viewPos + dir, 0, list.length - 1);
      renderViewCard();
      updateViewPos();
    }

    /* Menüü nupp viib alati tagasi pealehele; seal ei kuvata ühtegi nuppuriba. */
    el.btnMenu.addEventListener("click", ()=>{ showScreen("menu"); buildMenu(); });

    el.btnNext.addEventListener("click", ()=>{
      if(State.viewMode==="game"){
        const top = el.deck.querySelector(".swipeCard:last-child");
        if(top) commitSwipeGame(top, "EDASI");
      } else if(State.viewMode==="history" || State.viewMode==="best"){
        viewStep(+1);
      }
    });

    el.btnBack.addEventListener("click", ()=>{
      if(State.viewMode==="game"){
        const top = el.deck.querySelector(".swipeCard:last-child");
        if(top) commitSwipeGame(top, "TAGASI");
      } else if(State.viewMode==="history" || State.viewMode==="best"){
        viewStep(-1);
      }
    });

    el.btnBest.addEventListener("click", ()=>{
      const top = el.deck.querySelector(".swipeCard:last-child");
      if(top) commitSwipeGame(top, "PARIM");
    });

    /* Segab kaardid, et iga mäng oleks erinev. */
    function shuffle(arr){
      for(let i=arr.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [arr[i],arr[j]]=[arr[j],arr[i]];
      }
      return arr;
    }

    /* Clamp hoiab väärtused piirides, et animatsioonid ja thresholdid oleksid stabiilsed. */
    function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }

    buildMenu();
    showScreen("menu");
  </script>
</body>
</html>
